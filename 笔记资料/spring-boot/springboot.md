#一、介绍
>- ##Spring Boot是一个高层框架，底层为Spring Framework
>>- ![1](springboot_pic/springboot01.PNG)
>>- ![1](springboot_pic/springboot02.PNG)
>>- ###优点和缺点
>>>- ![1](springboot_pic/springboot03.PNG)
>>- ###Spring Boot的时代背景
>>>- ![1](springboot_pic/springboot04.PNG)
>>>- ####分布式 
>>>>- ![1](springboot_pic/springboot05.PNG)
>>>>- ![1](springboot_pic/springboot06.PNG)
>>>- ####云原生
>>>>- ![1](springboot_pic/springboot07.PNG)
>>>>- ![1](springboot_pic/springboot08.PNG)

#二、Spring Boot基础入门
>- ![1](springboot_pic/springboot10.PNG)
>- ##设置maven，修改maven的配置(maven根目录config文件夹下settings.xml)
>>     <mirrors>
>>         <mirror>
>>             <id>nexus-aliyun</id>
>>             <mirrorOf>central</mirrorOf>
>>             <name>Nexus-aliyun</name>
>>             <url>http://maven.aliyun.com/nexus/content/groups.public</url>
>>         </mirror>
>>     </mirrors>
>>     <profiles>
>>         <profile>
>>             <id>jdk-1.8</id>
>>             <activation>
>>                 <activeByDefault>true</activeByDefault>
>>                 <jdk>1.8</jdk>
>>             </activation>
>>             <properties>
>>                 <maven.compiler.source>1.8</maven.compiler.source>
>>                 <maven.compiler.target>1.8</maven.compiler.target>
>>                 <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>
>>             </properties>
>>         </profile>
>>     </profiles>
>- ##创建maven工程
>- ##引入依赖    
>>     <parent>
>>        <groupId>org.springframework.boot</groupId>
>>        <artifactId>spring-boot-starter-parent</artifactId>
>>        <version>2.3.4.RELEASE</version>
>>     </parent>
>>     <!--导入web场景-->
>>     <dependencies>
>>         <dependency>
>>             <groupId>org.springframework.boot</groupId>
>>             <artifactId>spring-boot-starter-web</artifactId>
>>         </dependency>
>>     </dependencies>
>- ##创建主程序类
>>- ![1](springboot_pic/springboot12.PNG)
>>- ###使用@SpringBootApplication注解
>>- ###创建main方法,设置启动run方法:
>>>-     SpringApplication.run(主程序类名.class);
>- ##编写业务并启动主程序类
>>- ![1](springboot_pic/springboot13.PNG)
>- ##测试
>- ##简化配置
>>- ###properties文件方式：资源文件夹下创建application.properties(文件名固定写法)
>>>- ####修改服务器端口号
>>>>     server.port=
>- ##简化部署
>>- ###把项目打成jar包，直接运行，无需部署到tomcat中(SpringBoot集成了Servlet容器)
>>>- ####导入插件
>>>>     <!--导入插件，直接把项目打包成jar包-->
>>>>     <build>
>>>>         <plugins>
>>>>             <plugin>
>>>>                 <groupId>org.springframework.boot</groupId>
>>>>                 <artifactId>spring-boot-maven-plugin</artifactId>
>>>>                 <version>2.7.2</version>
>>>>             </plugin>
>>>>         </plugins>
>>>>     </build>
>>>- ####点击maven生命周期中package(打包)功能直接打包
>>>- ####进入到target打包出来的文件夹，启动命令行，输入一下命令可以直接运行项目:
>>>>     java -jar jar包名.jar
>>>>- #####注意点：需要在cmd属性里取消快速编辑模式，否则鼠标点击命令行内容会导致项目无法启动成功
>- ##了解自动配置原理
>>- ###SpringBoot特点
>>>- ####1.依赖管理特性
>>>>     <parent>
>>>>        <groupId>org.springframework.boot</groupId>
>>>>        <artifactId>spring-boot-starter-parent</artifactId>
>>>>        <version>2.3.4.RELEASE</version>
>>>>     </parent>
>>>>- #####spring-boot-starter-parent的父项目
>>>>>       <parent>
>>>>>         <groupId>org.springframework.boot</groupId>
>>>>>         <artifactId>spring-boot-dependencies</artifactId>
>>>>>        <version>2.3.4.RELEASE</version>
>>>>>       </parent>
>>>>>- ######spring-boot-dependencies集成了很多依赖，几乎声明了所有开发中常用的jar的依赖的版本号，spring-boot-starter-parent继承了此项目，所以默认导入了这些依赖，且自动进行了版本管理，所以我们只需让项目继承spring-boot-starter-parent，即导入了依赖
>>>>>>- ![1](springboot_pic/springboot14.PNG)
>>>>>- ######在当前项目里重写配置(修改版本)
>>>>>>- ![1](springboot_pic/springboot15.PNG)
>>>>- #####spring-boot-starter-*:*代表某种场景，只要引入starter，这个场景所有常规需要的依赖就自动引入了
>>>>>- ######SpringBoot的starter所有支持的场景：https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter
>>>>>- ######见到的名字格式为：*-spring-boot-starter，一般是第三方提供的简化开发的场景启动器
>>>>>- ######所有场景启动器最底层的依赖
>>>>>>       <dependency>
>>>>>>           <groupId>org.springframework.boot</groupId>
>>>>>>           <artifactId>spring-boot-starter</artifactId>
>>>>>>           <version>2.3.4.RELEASE</version>
>>>>>>           <scope>compile</scope>
>>>>>>       </dependency>
>>>>- #####引入依赖默认都可以不写版本号；引入非版本仲裁的jar，需要写版本号
>>>- ####2.自动配置特性
>>>>- #####自动配好Tomcat
>>>>>- ######引入Tomcat依赖
>>>>>>      <dependency>
>>>>>>          <groupId>org.springframework.boot</groupId>
>>>>>>          <artifactId>spring-boot-starter-tomcat</artifactId>
>>>>>>          <version>2.3.4.RELEASE</version>
>>>>>>          <scope>compile</scope>
>>>>>>      </dependency> 
>>>>>- ######配置Tomcat
>>>>- #####自动配好SpringMVC
>>>>>- ######引入SpringMVC全部组件依赖
>>>>>>      <dependency>
>>>>>>          <groupId>org.springframework</groupId>
>>>>>>          <artifactId>spring-web</artifactId>
>>>>>>          <version>5.2.9.RELEASE</version>
>>>>>>          <scope>compile</scope>
>>>>>>      </dependency>
>>>>>>      <dependency>
>>>>>>          <groupId>org.springframework</groupId>
>>>>>>          <artifactId>spring-webmvc</artifactId>
>>>>>>          <version>5.2.9.RELEASE</version>
>>>>>>          <scope>compile</scope>
>>>>>>      </dependency>  
>>>>>- ######配置SpringMVC常用组件(功能)
>>>>- #####自动配好Web常见功能：比如编码过滤器
>>>>>- ######SpringBoot自动配好了所有web开发的常见场景
>>>>- #####默认的包结构
>>>>>- ######SpringBoot主程序所在的包及其子包所有的组件(注解标注)都能被默认扫描到，无需设置包扫描，如果需要扫描主程序包外的组件，则需给主程序类上的注解@SpringBootApplication写上scanBasePackages="包名"属性
>>>>>>     @SpringBootApplication(scanBasePackages="包名")
>>>>- #####各种配置拥有默认值
>>>>>- ######默认配置最终都是映射到MultipartProperties类上
>>>>>- ######配置文件的值最终都会绑定到某个类上，这个类会在容器中创建对象
>>>>- #####按需加载所有自动配置项
>>>>>- ######引入对应starter场景，对应的场景才会开启自动配置
>>>>>- ######SpringBoot所有自动配置功能都在spring-boot-autoconfigure包里
>>>>>>      <dependency>
>>>>>>          <groupId>org.springframework。boot</groupId>
>>>>>>          <artifactId>spring-boot-autoconfigure</artifactId>
>>>>>>          <version>2.3.4.RELEASE</version>
>>>>>>          <scope>compile</scope>
>>>>>>      </dependency> 
>>- ###容器功能
>>>- ####组件的添加
>>>>- #####@Configuration
>>>>>- ######属性：proxyBeanMethods:代理bean的方法，如果等于true，则在主程序类获取的配置类的实例实际上是被代理类增强了的代理对象，调用组件方法获取的实例为单实例；如果是false则获取的是配置类本身的实例，调用组件方法获取的实例不是单实例
>>>>>- ######在主程序类的包下或子包下创建配置类并用注解@Configuration标注此类
>>>>>>- ![1](springboot_pic/springboot17.PNG)
>>>>>>- 在主程序类中获取组件
>>>>>>>- ![1](springboot_pic/springboot19.PNG)
>>>>>>>- 配置类本身也是一个组件，也可以在主程序类获取到，如果获取配置类实例后调用组件方法，获取到的仍然是容器中的单实例实例(前提：proxyBeanMethods=true；proxyBeanMethods:@Configuration注解的属性，是代理bean的方法，如果等于true，则在主程序类获取的配置类的实例实际上是被代理类增强了的代理对象，调用组件方法获取的实例为单实例；如果是false则获取的是配置类本身的实例，调用组件方法获取的实例不是单实例)
>>>>- #####@Bean、@Component、@Controller、@Service、@Repository
>>>>>- ######@Bean
>>>>>>- 在配置类中编写方法并用@Bean标注此方法(给容器添加组件，以方法名作为组件的id。返回类型就是组件类型，返回的值就是在容器中的实例)，即可把组件添加到容器中(默认为单实例)
>>>>>>>- ![1](springboot_pic/springboot18.PNG)
>>>>- #####@ComponentScan、@Import
>>>>>- ######@Import
>>>>>>- ![1](springboot_pic/springboot20.PNG)
>>>>- #####@Conditional(条件装配)
>>>>>- ######@ConditionalOnBean(检测容器中是否存在指定的bean组件，不存在则标注的组件方法不生效(标注配置类则类中的所有组件方法不生效))
>>>>>>- ![1](springboot_pic/springboot21.PNG)
>>>- ####原生配置文件引入
>>>>- #####@ImportResource：使用次注解导入外部资源(配置文件)
>>>>>- ![1](springboot_pic/springboot22.PNG)
>>>>- #####@Component+@ConfigurationProperties
>>>>>- ![1](springboot_pic/springboot24.PNG)
>>>>>- ![1](springboot_pic/springboot23.PNG)
>>>>- #####@EnableConfigurationProperties(开启属性配置功能，使用了注解@ConfigurationProperties的类可以不使用注解加入容器中，SpringBoot会根据添加的class自动扫描加入)
>>>>>- ![1](springboot_pic/springboot25.PNG)
>>- ###自动配置原理入门
>>>- ####引导加载自动配置类@SpringBootApplication
>>>>- #####(1)@SpringBootConfiguration
>>>>>- ######@Configuration:代表当前类是一个配置类
>>>>- #####(2)EnableAutoConfiguration
>>>>>- ######@AutoConfigurationPackage
>>>>>>- @Import(AutoConfigurationPackages.Registrar.class):利用Registrar往容器中导入一系列组件，将指定的一个包下(主程序类所处于的包)的所有组件导入进来
>>>>>- ######@Import(AutoConfigurationImportSelector.class)
>>>>>>- 利用getAutoConfigurationEntry(annotationMetadata)给容器导入一些组件
>>>>>>- 调用List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes)获取所有需要导入到容器中的配置类
>>>>>>- 利用工厂记载 Map<String,List<String>> loadSpringFactories(@Nullable ClassLoader classloader)得到所有组件
>>>>>>- 从META-INF/spring.factories位置加载一个文件，默认扫描当前系统内所有META-INF/spring.factories位置的文件(spring-boot-autoconfigure.jar包里面有META-INF/spring.factories，意味着spring-boot一启动就要给容器中加载所有的配置类)
>>>>- #####(3)ConponentScan:包扫描
>>>- ####按需开启自动配置项
>>>>- #####虽然127个场景的所有自动配置启动的时候默认全部加载，但是有条件装配规则，最终会按需配置
>>>- ####定制化修改自动配置
>>>>- #####SpringBoot底层会自动配置组件，如果用户自己配了，则以用户配的优先。
>>>>- #####底层绑定的配置默认都是绑定配置文件指定的值
>>>>- #####需要修改底层的默认配置，则
>>>>>- ######@Bean注解添加组件到IOC容器
>>>>>- ######修改配置文件
>>>- ####最佳实践
>>>>- #####引入场景依赖
>>>>- #####查看自动配置了哪些
>>>>>- ######在配置文件里填写debug=true，启动SpringBoot即可查看,Negative(生效)/Positive(不生效)
>>>>- #####是否需要定制化(修改)
>>>>>- ######参照文档修改配置
>>>>>- ######自定义加入或者替代组件
>>>>- #####Lombok的使用
>>>>>- ######导入依赖
>>>>>>      <!--Lombok依赖-->
>>>>>>      <dependency>
>>>>>>          <groupId>org.projectlombok</groupId>
>>>>>>          <artifactId>lombok</artifactId>
>>>>>>      </dependency>
>>>>>- ######安装idea的lombok插件并重启idea
>>>>>- ######使用注解标记JavaBean类
>>>>>>- @Data:自动生成get和set方法
>>>>>>- @ToString:自动生成toString方法
>>>>>>- 构造器方法注解:
>>>>>>>- @AllArgsConstructor:全部属性的有参构造器
>>>>>>>- @NoArgsConstructor:无参构造器
>>>>>>- @Slf4j:日志
>>>>- #####热更新(实质是重新启动)
>>>>>- ######导入依赖
>>>>>>      <!--热更新-->
>>>>>>      <dependency>
>>>>>>          <groupId>org.springframework.boot</groupId>
>>>>>>          <artifactId>spring-boot-devtools</artifactId>
>>>>>>          <optional>true</optional>           
>>>>>>      </dependency>
>>>>>- ######Ctrl+F9启动重新编译
>>>>- #####Spring Initializr(idea快速创建SpringBoot项目)

#三、Spring Boot核心功能
>- ![1](springboot_pic/springboot10.PNG)
>- ##配置文件
>>- ###properties文件
>>- ###yaml文件
>>>- ####简介：
>>>> ![1](springboot_pic/springboot26.PNG)
>>>- ####语法：
>>>> ![1](springboot_pic/springboot27.PNG)
>>>- ####语法：
>>>> ![1](springboot_pic/springboot28.PNG)
>- ##web开发
>>- ###SpringMVC自动配置概览
>>- ###简单功能分析
>>>- ####静态资源访问
>>>>- #####静态资源目录
>>>>>- ######类路径下: called/static(or/public or/resources or/META-INF/resources)，在这些结构目录下都可以访问到静态资源
>>>>>>- 在配置文件中填写spring.mvc.static-path-pattern=/resources/**，请求路径即改变为'当前项目+static-path-pattern+静态资源名'(静态资源文件夹下找)
>>>>>>- 在配置文件中填写resources.static-locations=[classpath:/文件夹名/]，即静态资源只会在此文件夹下寻找
>>>>>>- 访问:当前项目根路径+静态资源名(请求会先经过控制层Controller寻找有没有能处理此请求的控制器方法，如果没有则访问静态资源，如果没有此资源，则404)
>>>>- #####webjar
>>>>>- ######导入依赖
>>>>>       <!--webjar-->
>>>>>       <dependency>
>>>>>           <groupId>org.webjars</groupId>
>>>>>           <artifactId>jquery</artifactId>
>>>>>           <version>3.5.1</version>
>>>>>       </dependency>
>>>>- #####访问地址:项目名/webjars/文件夹/资源 
>>>- ####欢迎页支持和favicon
>>>>- #####欢迎页默认index.html
>>>>>- ######可以配置静态资源路径resources.static-locations
>>>>- #####favicon小图标
>>>>>- 将favicon.ico放在静态资源目录下，浏览器选项卡的小图标即被替换为此图片
>>>- ####静态资源配置原理
>>>>- #####SpringBoot启动默认加载xxxAutoConfiguration(自动配置类)
>>>>- #####SpringMVC功能的自动配置类WebMvcAutoConfiguration
>>>>>- ######WebMvcAutoConfigurationAdapter
>>>>- #####resources:
>>>>>- ######add-mappings:false 禁用所有静态资源规则
>>>>>- ######cache:
>>>>>>- Period:11000 静态资源缓存11000秒
>>- ###请求参数处理
>>>- ####请求映射
>>>>- #####RESTFul风格:需要在配置文件中开启HiddenHttpMethodFilter过滤器：mvc.hiddenmethod.filter.enabled:true
>>>>>- ######额外兼容PUT/DELETE/PATCH方式的请求
>>>>- ##### 请求映射原理
>>>>> ![1](springboot_pic/springboot29.PNG)
>>>>>
>>>>> ![1](springboot_pic/springboot30.PNG)
>>>>> ![1](springboot_pic/springboot31.PNG)
>>>>> ![1](springboot_pic/springboot32.PNG)
>>>- ####普通参数与基本注解
>>>> ![1](springboot_pic/springboot33.PNG)
>>>>- #####@RequestAttribute
>>>>> ![1](springboot_pic/springboot34.PNG)
>>>>- #####矩阵变量
>>>>> ![1](springboot_pic/springboot35.PNG)
>>>>>- ######使用注解@MatrixVariable获取矩阵变量
>>>>>>- 因为SpringBoot自动移除url路径请求分号(;)后的内容，所以需要关闭移除功能，有两种方式：
>>>>>>>- 1.配置类实现WebMvcConfigurer接口，重写configurePathMatch方法![1](springboot_pic/springboot37.PNG)
>>>>>>>- 2.往IOC容器添加WebMvcConfigurer组件，也是重写configurePathMatch方法![1](springboot_pic/springboot38.PNG)
>>>>>>- 使用注解@MatrixVariable获取矩阵变量 ![1](springboot_pic/springboot36.PNG)![1](springboot_pic/springboot39.PNG)
>>>>>>>- 当多个矩阵变量的key值相同时，获取的写法![1](springboot_pic/springboot40.PNG)
>>>- ####POJO封装过程
>>>- ####参数处理原理
>>>>- 各种类型参数解析原理
>>>>>- ######注解：
>>>>>>![1](springboot_pic/springboot41.PNG)![1](springboot_pic/springboot42.PNG)![1](springboot_pic/springboot46.PNG)![1](springboot_pic/springboot43.PNG)![1](springboot_pic/springboot44.PNG)![1](springboot_pic/springboot45.PNG)![1](springboot_pic/springboot47.PNG)![1](springboot_pic/springboot48.PNG)![1](springboot_pic/springboot49.PNG)![1](springboot_pic/springboot55.PNG)
>>>>>- Servlet API：
>>>>>>![1](springboot_pic/springboot50.PNG)
>>>>>- ######复杂参数：
>>>>>>![1](springboot_pic/springboot51.PNG)![1](springboot_pic/springboot52.PNG)![1](springboot_pic/springboot53.PNG)![1](springboot_pic/springboot54.PNG)
>>>>>- ######自定义对象参数：
>>>>>>![1](springboot_pic/springboot56.PNG)![1](springboot_pic/springboot57.PNG)![1](springboot_pic/springboot58.PNG)
>>>>>- ######自定义Converter
>>>>>>![1](springboot_pic/springboot60.PNG)
>>>>>>- #####两种方式
>>>>>>>- 1.配置类实现WebMvcConfigurer接口，重写addFormatters方法
>>>>>>>- 2.往IOC容器添加WebMvcConfigurer组件，也是重写addFormatters方法 ![1](springboot_pic/springboot61.PNG)
>>- ###数据响应与内容协商
>>>- ####响应JSON
>>>>- #####jackson.jar+@ResponseBody
>>>>>- ######SpringBoot的web场景已经自动引入了json依赖 
>>>>>- ######使用注解@ResponseBody标注控制器方法，访问此控制器时即可返回json数据
>>>>>>![1](springboot_pic/springboot62.PNG)
>>>>- HTTPMessageConverter
>>>- ####内容协商(根据客户端的接收能力不同，返回不同媒体类型的数据)
>>>>- #####引入XML依赖
>>>>>       <!--XML依赖-->
>>>>>       <dependency>
>>>>>           <groupId>com.fasterxml.jackson.dataformat</groupId>
>>>>>           <artifactId>jackson-dataformat-xml</artifactId>             
>>>>>       </dependency>             
>>>> ![1](springboot_pic/springboot63.PNG)
>>>> ![1](springboot_pic/springboot64.PNG)
>>>> ![1](springboot_pic/springboot65.PNG)
>>>- ####自定义MessageConverter 
>>>> ![1](springboot_pic/springboot66.PNG)
>>>>
>>>> ![1](springboot_pic/springboot67.PNG)
>>>>
>>>> ![1](springboot_pic/springboot68.PNG)
>>>>- #####1.重写有两种方式
>>>>>- 1.配置类实现WebMvcConfigurer接口，重写extendMessageConverters方法(拓展更多自定义MessageConverter),或者configureMessageConverters(覆盖原生的MessageConverter)
>>>>>- 2.往IOC容器添加WebMvcConfigurer组件，也是重写extendMessageConverters方法或configureMessageConverters方法 ![1](springboot_pic/springboot69.PNG)
>>>>- #####2.编写自定义Converter类
>>>>>- ######创建一个类并实现 HttpMessageConverter<此处填写想要接收的数据类> 接口，并重写以下方法 
>>>>>>- ![1](springboot_pic/springboot70.PNG)
>>>>- #####3.使浏览器兼容自定义的Converter(有两种内容协商策略:1.参数；2.请求头)
>>>>>- ######在WebMvcConfigurer组件内重写configureContentNegotiation方法
>>>>>>- ![1](springboot_pic/springboot71.PNG)
>>- ###视图解析与模板引擎
>>> ![1](springboot_pic/springboot72.PNG)
>>>- ####在SpringBoot里使用只需引入依赖便自动配置完成
>>>>        <!--Thymeleaf场景依赖-->
>>>>        <dependency>
>>>>            <groupId>org.springframework.boot</groupId>
>>>>            <artifactId>spring-boot-starter-thymeleaf</artifactId>
>>>>        </dependency>
>>>> ![1](springboot_pic/springboot73.PNG)
>>>> 
>>>> 默认指定了路径和页面后缀![1](springboot_pic/springboot74.PNG)
>>>> 在配置文件指定控制器访问路径(访问任何控制器都需要在路径前添加此指定内容)：server.servlet.context-path:
>>- ###拦截器
>>>- ####配置拦截器
>>>>- #####创建一个拦截器类并实现HandlerInterceptor接口
>>>>- #####重写preHandle、postHandle、afterCompletion方法
>>>>>- 登录检查逻辑![1](springboot_pic/springboot75.PNG)
>>>>- #####重写WebMvcConfigurer的addInterceptor方法,需放行静态资源的访问
>>>>>- 登录检查逻辑![1](springboot_pic/springboot76.PNG)
>>- ###文件上传
>>>- ![1](springboot_pic/springboot78.PNG)
>>>- 修改单个文件上传的最大大小
>>>>- ![1](springboot_pic/springboot79.PNG)
>>>- 修改请求整体文件上传的最大大小
>>>>- ![1](springboot_pic/springboot80.PNG)
>>- ###跨域
>>- ###异常处理
>>>- ![1](springboot_pic/springboot81.PNG)
>>>>- #####在模板路径下创建error文件，把错误页面放到此目录下(5xx格式对应500类型的错误，具体名字404则只对应404错误)
>>>> ![1](springboot_pic/springboot82.PNG)
>>>- ####自定义处理
>>>>- #####@ControllerAdvice+@ExceptionHandler处理全局异常
>>>>>- ######1.创建异常处理类，并用注解@ControllerAdvice标注
>>>>>- ######2.创建异常处理方法，并用注解@ExceptionHandler标注
>>>>>> ![1](springboot_pic/springboot83.PNG)
>>>>- #####@ResponseStatus处理自定义异常
>>>>>- ######1.创建一个类继承RuntimeException类，并用@ResponseStatus标注
>>>>>> ![1](springboot_pic/springboot84.PNG)
>>>>>- ######2.在控制器方法内引用
>>>>>> ![1](springboot_pic/springboot85.PNG)
>>>>- #####自定义实现HandlerExceptionResolver处理异常()
>>>>>- ######1.创建一个类实现HandlerExceptionResolver接口
>>>>>- ######2.重写resolverException方法
>>>>>>- #####ErrorViewResolver实现自定义处理异常
>>>>>> ![1](springboot_pic/springboot87.PNG)
>>>>>> ![1](springboot_pic/springboot86.PNG)
>>- ###原生Servlet组件
>>>- ####1.使用Servlet API
>>>>- #####创建一个类继承HttpServlet，并用注解@WebServlet标注(不会被spring拦截器拦截)
>>>>> ![1](springboot_pic/springboot88.PNG)
>>>>- #####在主程序类上使用注解@ServletComponentScan标注
>>>>> ![1](springboot_pic/springboot89.PNG)
>>>>- #####配置原生过滤器：创建一个类实现Filter接口并用注解@WebFilter标注，并重写init、doFilter、destroy方法
>>>>> ![1](springboot_pic/springboot90.PNG)
>>>>- #####配置原生监听器：创建一个类实现ServletContextListener接口并用注解@WebListener标注，并重写contextInitialized(项目初始化)、contextDestroyed(项目销毁)方法
>>>>> ![1](springboot_pic/springboot91.PNG)
>>>- ####2.使用RegistrationBean
>>>>- 创建一个配置类(@Configuration标注)
>>>>- 注入RegistrationBean组件，添加Servlet原生API
>>>>> ![1](springboot_pic/springboot88.PNG)
>>>>>
>>>>> ![1](springboot_pic/springboot90.PNG)
>>>>>
>>>>> ![1](springboot_pic/springboot91.PNG)
>>>>>
>>>>> ![1](springboot_pic/springboot92.PNG)
>>>>> ![1](springboot_pic/springboot93.PNG)
>>>>> ![1](springboot_pic/springboot94.PNG)
>>- ###嵌入式Web容器
>>> ![1](springboot_pic/springboot95.PNG)
>>> ![1](springboot_pic/springboot96.PNG)
>>> ![1](springboot_pic/springboot98.PNG)
>>>- 切换web容器
>>>> ![1](springboot_pic/springboot97.PNG)
>>- ###定制化原理
>>> ![1](springboot_pic/springboot99.PNG)
>>> ![1](springboot_pic/springboot100.PNG)
>- ##数据访问
>>- ###数据访问
>>>- ####SQL
>>>>- #####1.数据源的自动配置
>>>>>- ######JDBC场景
>>>>>>- 导入依赖
>>>>>>>     <!--JDBC场景依赖-->            
>>>>>>>     <dependency>            
>>>>>>>         <groupId>org.springframework.boot</groupId>
>>>>>>>         <artifactId>spring-boot-starter-data-jdbc</artifactId>
>>>>>>>     </dependency>   
>>>>>>>
>>>>>>>     <!--MYSQL依赖-->            
>>>>>>>     <dependency>            
>>>>>>>         <groupId>mysql</groupId>
>>>>>>>         <artifactId>mysql-connector-java</artifactId>
>>>>>>>     </dependency> 
>>>>>>> ![1](springboot_pic/springboot101.PNG)
>>>>>>- 配置数据源
>>>>>>> ![1](springboot_pic/springboot102.PNG)
>>>>>- ######分析自动配置
>>>>>> ![1](springboot_pic/springboot103.PNG)
>>>>>> ![1](springboot_pic/springboot104.PNG)
>>>>- #####2.使用Druid数据源
>>>>>- ######自定义方式
>>>>>>- 导入依赖
>>>>>>>     <!--导入druid数据源-->           
>>>>>>>     <dependency>            
>>>>>>>         <groupId>com.alibaba</groupId>
>>>>>>>         <artifactId>druid</artifactId>
>>>>>>>         <version>1.1.17</version>
>>>>>>>     </dependency> 
>>>>>> ![1](springboot_pic/springboot105.PNG)
>>>>>> ![1](springboot_pic/springboot106.PNG)
>>>>>>-  配置druid的监控页功能
>>>>>>> ![1](springboot_pic/springboot107.PNG)
>>>>>- ######使用官方starter场景依赖方式
>>>>>>- 引入依赖
>>>>>>>     <!--导入druid的starter场景依赖-->          
>>>>>>>     <dependency>   
>>>>>>>         <groupId>com.alibaba</groupId>    
>>>>>>>         <artifactId>druid-spring-boot-starter</artifactId>   
>>>>>>>         <version>1.1.17</version>
>>>>>>>     </dependency>
>>>>>>>- 分析自动配置
>>>>>>>> ![1](springboot_pic/springboot108.PNG)
>>>>- #####3.整合MyBatis操作
>>>>>- 导入依赖
>>>>>>        <!--MyBatis依赖-->        
>>>>>>        <dependency>
>>>>>>            <groupId>org.mybatis.spring.boot</groupId>
>>>>>>            <artifactId>mybatis-spring-boot-starter</artifactId>
>>>>>>            <version>2.2.2</version>
>>>>>>        </dependency>
>>>>>- 配置有三种方式：
>>>>>>- 配置模式: 
>>>>>>>![1](springboot_pic/springboot110.PNG)![1](springboot_pic/springboot111.PNG)![1](springboot_pic/springboot112.PNG)
>>>>>>>- 配置文件里指定MyBatis全局配置文件的位置：mybatis.config-location:classpath:
>>>>>>>- 创建MyBatis全局配置文件，不需要配置内容，场景依赖已经将其自动配置
>>>>>>>- 创建对应的mapper接口且使用注解@Mapper标注(也可在主程序类添加注解@MapperScan扫描mapper包)，资源目录下创建mapper映射文件；在配置文件指定其位置：mybatis.mapper-locations:classpath:；映射文件绑定mapper接口
>>>>>>- 注解模式
>>>>>>>- 导入依赖后创建mapper接口并用注解@Mapper标注(也可在主程序类添加注解@MapperScan扫描mapper包)，编写方法并用@Select等注解标注并编写SQL语句，使用@Options可以添加属性![1](springboot_pic/springboot113.PNG)![1](springboot_pic/springboot114.PNG)
>>>>>>- 混合模式(两种方式同时使用无冲突)
>>>>- #####4.整合MyBatisPlus操作
>>>>>- ######配置：
>>>>>>- 安装MyBatisX插件
>>>>>>- 引入依赖
>>>>>>>     <!--MyBatisPlus依赖-->
>>>>>>>     <dependency>
>>>>>>>         <groupId>com.baomidou</groupId>
>>>>>>>         <artifactId>mybatis-plus-boot-starter</artifactId>
>>>>>>>         <version>3.5.2</version>
>>>>>>>     </dependency>
>>>>>>- ![1](springboot_pic/springboot115.PNG)
>>>>>>- 创建对应的mapper接口，继承BaseMapper<想操作的POJO实体泛型>，且使用注解@Mapper标注(也可在主程序类添加注解@MapperScan扫描mapper包)，即可获得CRUD功能
>>>- ####NoSQL
>>>>- #####Redis
>>>>>- ######配置：
>>>>>>- 导入依赖：
>>>>>>>     <!--redis场景依赖-->
>>>>>>>     <dependency>
>>>>>>>         <groupId>org.springframework.boot</groupId>
>>>>>>>         <artifactId>spring-boot-starter-data-redis</artifactId>
>>>>>>>     </dependency>
>>>>>>- ![1](springboot_pic/springboot116.PNG)
>>>>>>- 环境搭建：
>>>>>>>- 阿里云按量付费redis
>>>>>>>- 申请redis的公网连接地址
>>>>>>- 配置文件：
>>>>>>> ![1](springboot_pic/springboot117.PNG)
>- ##单元测试
>>- ###Junit5
>>> ![1](springboot_pic/springboot118.PNG)![1](springboot_pic/springboot119.PNG)![1](springboot_pic/springboot120.PNG)![1](springboot_pic/springboot121.PNG)![1](springboot_pic/springboot122.PNG)![1](springboot_pic/springboot123.PNG)![1](springboot_pic/springboot124.PNG)![1](springboot_pic/springboot125.PNG)![1](springboot_pic/springboot126.PNG)![1](springboot_pic/springboot127.PNG)![1](springboot_pic/springboot128.PNG)![1](springboot_pic/springboot129.PNG)![1](springboot_pic/springboot130.PNG)![1](springboot_pic/springboot131.PNG)![1](springboot_pic/springboot132.PNG)
>>>- 配置：
>>>>- 引入依赖(SpringBoot2.4以上版本移除了默认对Vintage的依赖，如需兼容Junit4需自行引入)：
>>>>>       <!--Junit5场景依赖-->
>>>>>       <dependency>
>>>>>           <groupId>org.springframework.boot</groupId>
>>>>>           <artifactId>spring-boot-starter-test</artifactId>
>>>>>       </dependency>
>>>>>
>>>>>       <!--兼容Junit4-->
>>>>>       <dependency>
>>>>>           <groupId>org.junit.vintage</groupId>
>>>>>           <artifactId>junit-vintage-engine</artifactId>
>>>>>           <scope>test</scope>
>>>>>           <exclusions>
>>>>>               <exclusion>
>>>>>                   <groupId>org.hamcrest</groupId>
>>>>>                   <artifactId>hamcrest-core</artifactId>
>>>>>               </exclusion>
>>>>>           </exclusions>
>>>>>       </dependency>
>>>- 在测试目录下创建一个类，使用注解@SpringBootTest(使用spring容器)，创建测试方法，使用注解@Test标注
>- ##指标监控
>> ![1](springboot_pic/springboot133.PNG)![1](springboot_pic/springboot134.PNG)![1](springboot_pic/springboot135.PNG)
>>- EndPoint:
>>> ![1](springboot_pic/springboot139.PNG)![1](springboot_pic/springboot140.PNG)![1](springboot_pic/springboot141.PNG)![1](springboot_pic/springboot138.PNG)![1](springboot_pic/springboot142.PNG)![1](springboot_pic/springboot143.PNG)
>>- ###SpringBoot Actuator和EndPoint
>>>- ####配置：
>>>>- #####引入依赖
>>>>>       <!--引入监控功能-->
>>>>>       <dependency>
>>>>>           <groupId>org.springframework.boot</groupId>
>>>>>           <artifactId>spring-boot-starter-actuator</artifactId>
>>>>>       </dependency>
>>>>- #####配置文件设置
>>>>> ![1](springboot_pic/springboot137.PNG)![1](springboot_pic/springboot144.PNG)
>>>>- #####定制EndPoint，创建一个类继承AbstractHealthIndicator类，重写doHealthCheck方法，并作为组件加入IOC容器(@Component)
>>>>> ![1](springboot_pic/springboot145.PNG)
>>>>- #####Boot Admin Server(可视化指标监控)
>>>>>- #####引入依赖
>>>>>>      <dependency>
>>>>>>          <groupId>de.codecentrict</groupId>
>>>>>>          <artifactId>spring-boot-admin-starter-server</artifactId>
>>>>>>          <version>2.7.5</version>
>>>>>>      </dependency>
>>>>>- #####在主程序类上使用注解@EnableAdminServer标注
>>>>>- #####注册客户端
>>>>>>- 引入依赖
>>>>>>>     <dependency>
>>>>>>>         <groupId>de.codecentric</groupId>
>>>>>>>         <artifactId>spring-boot-admin-starter-client</artifactId>
>>>>>>>         <version>2.7.5</version>
>>>>>>>     </dependency>
>>>>>>- 在配置文件里填写汇报的服务器地址：spring.boot.admin.client.url=http://localhost:服务器端口号
>>>>>>- 在配置文件里配置以web方式暴露端点：management.endpoints.web.exposure.include=*
>- ##原理解析
>> ![1](springboot_pic/springboot146.PNG)![1](springboot_pic/springboot150.PNG)![1](springboot_pic/springboot152.PNG)![1](springboot_pic/springboot153.PNG)![1](springboot_pic/springboot154.PNG)![1](springboot_pic/springboot156.PNG)![1](springboot_pic/springboot157.PNG)![1](springboot_pic/springboot158.PNG)![1](springboot_pic/springboot159.PNG)
>>- ###生产环境的切换：
>>>- ####配置文件名后缀：application-test：测试环境!
>>>> ![1](springboot_pic/springboot147.PNG)
>>>- ####启用生产环境：在默认配置文件application里填写：spring.profiles.active=
>>>> ![1](springboot_pic/springboot148.PNG)
>>>>- 打包后命令行激活生产环境：
>>>>>![1](springboot_pic/springboot149.PNG)
>>>- ####分组启用生产环境 
>>>>![1](springboot_pic/springboot151.PNG)
#四、Spring Boot场景整合
>- ![1](springboot_pic/springboot10.PNG)
